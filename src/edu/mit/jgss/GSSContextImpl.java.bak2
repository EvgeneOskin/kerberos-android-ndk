/* 
 * Copyright (C) 2012 by the Massachusetts Institute of Technology.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.mit.jgss;

import org.ietf.jgss.GSSException;
import org.ietf.jgss.Oid;
import org.ietf.jgss.GSSName;
import org.ietf.jgss.GSSCredential;
import org.ietf.jgss.ChannelBinding;
import org.ietf.jgss.MessageProp;
import org.ietf.jgss.GSSContext;

import edu.mit.jgss.swig.*;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

public class GSSContextImpl implements GSSContext {
    
    /* representing our underlying SWIG-wrapped gss_ctx_id_t object */
    private gss_ctx_id_t_desc internGSSCtx = new gss_ctx_id_t_desc();
    
    /* has this context been destroyed? */ 
    private boolean invalid = false;

    /* context state */
    private enum State { UNINIT, INPROG, DONE, DISPOSED }

    /* variables set during context creation */
    private GSSCredentialImpl credential = null;
    private GSSCredentialImpl delegCredential = null;
    private GSSNameImpl targetName = null;
    private GSSNameImpl srcName = null;
    private OidImpl mech = null;
    private ChannelBinding channelBinding = new ChannelBinding(null, null, null);
    //private ChannelBinding channelBinding = null;

    /* use default lifetime at first */
    private int lifetime = GSSContext.DEFAULT_LIFETIME;

    /* state flags */
    private boolean requestCredDeleg   = false;
    private boolean requestMutualAuth  = false;
    private boolean requestReplayDet   = false;
    private boolean requestSequenceDet = false;
    private boolean requestConf        = false;
    private boolean requestInteg       = false;
    private boolean requestAnonymity   = false;
    private boolean isProtReady        = false;
    private boolean isTransferable     = false;

    /* designate if this is an initiator or acceptor context */
    private boolean initiator = false;

    /* keep track of our context state */
    private State ctxState = State.UNINIT;

    /* creating context on the initiator side */
    public GSSContextImpl(GSSName peer, Oid mech, GSSCredential myCred,
            int lifetime) throws GSSException {
        
        if (peer != null) {
            this.targetName = (GSSNameImpl)peer;
            System.out.println("Storing targetName, name = " + peer.toString());
        } else {
            throw new GSSException(GSSException.BAD_NAME);
        }

        if (mech == null) {
            /* default native mech = gss_mech_krb5 */
            System.out.println("Mech is null, setting to default");
            this.mech = new OidImpl("1.2.840.113554.1.2.2");
        } else {
            System.out.println("Input mech is not null, using it");
            this.mech = (OidImpl) mech;
        }

        if (myCred != null) {
            this.credential = (GSSCredentialImpl) myCred;
            System.out.println("Storing credential...");
            this.srcName = (GSSNameImpl) myCred.getName();
            System.out.println("Storing srcName, name = " + srcName.toString());
        }

        if (lifetime >= 0) {
            System.out.println("Setting lifetime to " + lifetime + " sec.");
            this.lifetime = lifetime;
        }

        this.invalid = false;
        this.initiator = true;
    }

    /* creating a context on the acceptor side */
    public GSSContextImpl(GSSCredential myCred) throws GSSException {

        if (myCred != null) {
            credential = (GSSCredentialImpl) myCred;
            srcName = (GSSNameImpl) credential.getName();
        } else {
            /* TODO - use "null" to act as a default acceptor principal, 
               set defaults for everything? */
            // credential = GSS_C_NO_CREDENTIAL
            // srcName = GSS_C_NO_NAME?
        }

        this.initiator = false;
    }

    public byte[] initSecContext(byte[] inputBuf, int offset, int len) 
        throws GSSException {

        long maj_status = 0;
        long[] min_status = {0};
        int ret = 0;

        ByteArrayInputStream bis = new ByteArrayInputStream(inputBuf,
                offset, len);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        ret = initSecContext(bis, bos); 

        return bos.toByteArray();
    }

    /* 
     * Returns the number of bytes written to the outpustream, or 0 if
     * none need to be written 
     */
    public int initSecContext(InputStream inStream, OutputStream outStream) 
        throws GSSException {

        long maj_status = 0;
        long[] min_status = {0};
        long[] actual_flags = {0};
        long[] time_rec = {0};
        gss_OID_desc actual_mech_type = new gss_OID_desc();
        byte[] inputTokArray;

        /* setup temporary context */
        gss_ctx_id_t_desc context_tmp;
        if (ctxState == State.UNINIT) {
            context_tmp = gsswrapper.GSS_C_NO_CONTEXT;
        } else {
            context_tmp = internGSSCtx;
        }

        /* setup output token */
        gss_buffer_desc outputToken = new gss_buffer_desc();
        outputToken.setLength(0);
        outputToken.setValue(null);

        ByteArrayOutputStream outTok = new ByteArrayOutputStream();

        try {
            if (inStream.available() > 0) {
                /* retrieve token header to get token length */
                DerHeader tokHeader = DerUtil.getHeader(inStream);

                System.out.println("Read token header, size = " + tokHeader.getLength());
       
                /* put our header bytes back */
                outTok.write(tokHeader.getBytes());

                /* copy over the rest of our input token */
                for (int i = 0; i < tokHeader.getLength(); i++) {
                    outTok.write(inStream.read());
                }
            }

        } catch (IOException e) {
            /* I/O Error occurred when reading InputStream */
            System.out.println("I/O Error occurred when reading InputStream");
            throw new GSSException(GSSException.FAILURE);
        }
       
        /* read token into byte array, gss_buffer_desc for native gssapi */
        inputTokArray = outTok.toByteArray();
        gss_buffer_desc inputToken = new gss_buffer_desc();
        System.out.println("inputTokArray length = " + inputTokArray.length);
        if (inputTokArray != null && inputTokArray.length > 0) {
            gsswrapper.setDescArray(inputToken, inputTokArray);
            inputToken.setLength(inputTokArray.length);
        }

        /* get requested flags */
        long requestedFlags = getRequestedFlags();

        /* debug tests */
        System.out.println("srcName = " + srcName.toString());
        System.out.println("targetName = " + targetName.toString());
        System.out.println("mech = " + mech.getNativeOid().toString());
        System.out.println("requestedFlags = " + requestedFlags);
        System.out.println("lifetime = " + lifetime); /* TODO */
        System.out.println("cred for = " + credential.getName().toString());

        maj_status = gsswrapper.gss_init_sec_context(min_status,
                credential.getInternGSSCred(),
                context_tmp,
                targetName.getInternGSSName(),
                mech.getNativeOid(),
                requestedFlags,
                lifetime,
                channelBinding.getNativeChannelBindings(),
                inputToken,
                actual_mech_type,
                outputToken,
                actual_flags,
                time_rec);

        if (maj_status == gsswrapper.GSS_S_CONTINUE_NEEDED) {
            /* gss_init_sec_context needs to be called again with output
               token from gss_accept_sec_context. */
            System.out.println("Requires another token to be sent");
            ctxState = State.INPROG;
        } else if (maj_status != gsswrapper.GSS_S_COMPLETE) {
            throw new GSSExceptionImpl((int) maj_status, (int) min_status[0]);
        } else {
            ctxState = State.DONE;
        }

        /* save native context */
        internGSSCtx = context_tmp;

        /* set some context variables */
        this.lifetime = (int) time_rec[0];

        //mech.setNativeOid(actual_mech_type);
        mech = new OidImpl(actual_mech_type.toDotString());
        // TODO - release actual_mech_type?

        setReturnedFlags(actual_flags[0]);

        /* place output token into OutputStream */ 
        if (outputToken.getLength() > 0) {
            byte[] temp_token = new byte[(int)outputToken.getLength()];
            temp_token = gsswrapper.getDescArray(outputToken);
            gsswrapper.gss_release_buffer(min_status, outputToken);
            try {
                outStream.write(temp_token);
            } catch (IOException e) {
                throw new GSSException(GSSException.FAILURE);
            }
            return temp_token.length;
        } else {
            return 0;
        }

    }

    public byte[] acceptSecContext(byte[] inTok, int offset, int len)
        throws GSSException{
    
        long maj_status = 0;
        long[] min_status = {0};
        long[] actual_flags = {0};
        long[] time_rec = {0};
        //gss_OID_desc actual_mech_type = new gss_OID_desc();
        gss_cred_id_t_desc delegatedCred = new gss_cred_id_t_desc();
        
        gss_buffer_desc outputToken = new gss_buffer_desc();
        outputToken.setLength(0);
        outputToken.setValue(null);

        /* get actual input token */
        byte[] actualInBuf = new byte[len];
        System.arraycopy(inTok, offset, actualInBuf, 0, len);

        gss_buffer_desc inputToken = new gss_buffer_desc();
        if (inTok != null && len > 0) {
            gsswrapper.setDescArray(inputToken, actualInBuf);
            inputToken.setLength(actualInBuf.length);
        }

        long requestedFlags = getRequestedFlags();
        
        /* set up our temporary context */ 
        gss_ctx_id_t_desc context_tmp;
        if (ctxState == State.UNINIT) {
            context_tmp = gsswrapper.GSS_C_NO_CONTEXT;
        } else {
            context_tmp = internGSSCtx;
        }

        if (inputToken == null)
            System.out.println("inputToken is null");
        if (srcName == null)
            System.out.println("sourceName is null");
        if (mech == null)
            System.out.println("mech is null");

        maj_status = gsswrapper.gss_accept_sec_context(min_status,
                //internGSSCtx,
                context_tmp,
                //credential.getInternGSSCred(),
                gsswrapper.GSS_C_NO_CREDENTIAL,
                inputToken,
                channelBinding.getNativeChannelBindings(),
                srcName.getInternGSSName(),
                //actual_mech_type,
                null,
                outputToken,
                actual_flags,
                time_rec,
                delegatedCred);

        if (maj_status == gsswrapper.GSS_S_CONTINUE_NEEDED) {
            ctxState = State.INPROG;
            System.out.println("Requires another token to be sent");
        } else if (maj_status != gsswrapper.GSS_S_COMPLETE) {
            throw new GSSExceptionImpl((int) maj_status, (int)min_status[0]);
        } else {
            ctxState = State.DONE;
        }
        
        /* set some context variables */
        setReturnedFlags(actual_flags[0]);
        this.lifetime = (int) time_rec[0];
        if (delegCredential == null)
            delegCredential = new GSSCredentialImpl();
        delegCredential.setInternGSSCred(delegatedCred);
        if (mech == null)
            this.mech = new OidImpl("1.2.840.113554.1.2.2");
        //this.mech.setNativeOid(actual_mech_type);
        
        /* set context */
        internGSSCtx = context_tmp;

        /* get the byte[] from our outputToken and return */
        if (outputToken.getLength() > 0) {
            byte[] temp_token = new byte[(int)outputToken.getLength()];
            temp_token = gsswrapper.getDescArray(outputToken);
            gsswrapper.gss_release_buffer(min_status, outputToken);
            return temp_token;
        } else {
            return null;
        }
    }

    public void acceptSecContext(InputStream inStream, OutputStream outStream)
        throws GSSException {

        long maj_status = 0;
        long[] min_status = {0};
        long[] actual_flags = {0};
        long[] time_rec = {0};
        gss_cred_id_t_desc delegatedCred = new gss_cred_id_t_desc();
        byte[] inputTokArray;

        /* setup temporary context */
        gss_ctx_id_t_desc context_tmp;
        if (ctxState == State.UNINIT) {
            context_tmp = gsswrapper.GSS_C_NO_CONTEXT;
        } else {
            context_tmp = internGSSCtx;
        }

        /* setup output token */
        gss_buffer_desc outputToken = new gss_buffer_desc();
        outputToken.setLength(0);
        outputToken.setValue(null);

        ByteArrayOutputStream outTok = new ByteArrayOutputStream();

        try {
            if (inStream.available() > 0) {
                /* retrieve token header to get token length */
                DerHeader tokHeader = DerUtil.getHeader(inStream);

                System.out.println("Read token header, size = " + tokHeader.getLength());

                /* put our header bytes back */
                outTok.write(tokHeader.getBytes());

                /* copy over the rest of the input token */
                for (int i = 0; i < tokHeader.getLength(); i++) {
                    outTok.write(inStream.read());
                }
            }

        } catch (IOException e) {
            /* I/O Error occurred when reading InputStream */
            System.out.println("I/O Error occurred when reading InputStream");
            throw new GSSException(GSSException.FAILURE);
        }

        /* read token into byte array, gss_buffer_desc for native gssapi */
        inputTokArray = outTok.toByteArray();
        gss_buffer_desc inputToken = new gss_buffer_desc();
        System.out.println("inputTokArray length = " + inputTokArray.length);
        if (inputTokArray != null && inputTokArray.length > 0) {
            gsswrapper.setDescArray(inputToken, inputTokArray);
            inputToken.setLength(inputTokArray.length);
        }

        long requestedFlags = getRequestedFlags();

        maj_status = gsswrapper.gss_accept_sec_context(min_status,
                context_tmp,
                credential.getInternGSSCred(),
                // gsswrapper.GSS_C_NO_CREDENTIAL
                inputToken,
                channelBinding.getNativeChannelBindings(),
                srcName.getInternGSSName(),
                // actual_mech_type
                null,
                outputToken,
                actual_flags,
                time_rec,
                delegatedCred);

        if (maj_status == gsswrapper.GSS_S_CONTINUE_NEEDED) {
            ctxState = State.INPROG;
            System.out.println("Requires another token to be sent");
        } else if (maj_status != gsswrapper.GSS_S_COMPLETE) {
            throw new GSSExceptionImpl((int)maj_status, (int)min_status[0]);
        } else {
            ctxState = State.DONE;
        }

        /* set context */
        internGSSCtx = context_tmp;

        /* save some context variables */
        this.lifetime = (int) time_rec[0];

        if (mech == null)
            this.mech = new OidImpl("1.2.840.113554.1.2.2");

        setReturnedFlags(actual_flags[0]);

        if (delegatedCred == null)
            delegCredential = new GSSCredentialImpl();
        delegCredential.setInternGSSCred(delegatedCred);

        /* place output token into OutputStream */
        if (outputToken.getLength() > 0) {
            byte[] temp_token = new byte[(int)outputToken.getLength()];
            temp_token = gsswrapper.getDescArray(outputToken);
            gsswrapper.gss_release_buffer(min_status, outputToken);
            try {
                outStream.write(temp_token);
            } catch (IOException e) {
                throw new GSSException(GSSException.FAILURE);
            }
        }

    }

    public boolean isEstablished() {
        if (ctxState == State.DONE)
            return true;

        return false;
    }

    /**
     * Deletes one end of the security context, also deleting local data
     * structures associated with the security context. This needs to be 
     * called on both initiator and acceptor sides to close both ends of 
     * the security context.
     */
    public void dispose() throws GSSException {
        
        if (!invalid) { 
            long maj_status = 0;
            long[] min_status = {0};
            gss_buffer_desc output_token = gsswrapper.GSS_C_NO_BUFFER;

            maj_status = gsswrapper.gss_delete_sec_context(
                    min_status, 
                    this.internGSSCtx, 
                    output_token);

            gsswrapper.gss_release_buffer(min_status, output_token);

            if (maj_status != gsswrapper.GSS_S_COMPLETE) {
                /* throw new GSSExceptionImpl((int) maj_status, 
                        (int) min_status[0]); */
            }

            this.invalid = true;
            ctxState = State.DISPOSED;
            srcName = null;
            targetName = null;
            credential = null;
            delegCredential = null;

            System.out.println("Deleted security context.");
        }

    }

    public int getWrapSizeLimit(int qop, boolean confReq, int maxTokenSize)
        throws GSSException {

        long maj_status = 0;
        long[] min_status = {0};
        long[] max_size = {0};
        int conf_req = 0;

        if(confReq)
            conf_req = 1;

        maj_status = gsswrapper.gss_wrap_size_limit(min_status,
                this.internGSSCtx, conf_req, (long) qop, 
                (long) maxTokenSize, max_size);

        if (maj_status != gsswrapper.GSS_S_COMPLETE) {
            throw new GSSExceptionImpl((int) maj_status, (int) min_status[0]);
        }

        return (int)max_size[0];
    }

    public byte[] wrap(byte[] inBuf, int offset, int len, MessageProp msgProp)
        throws GSSException {

        long maj_status = 0;
        long[] min_status = {0};
        int[] state = {0};
        int conf_req = 0;
        gss_buffer_desc outputMsg = new gss_buffer_desc();
        
        /* get actual input buffer */
        byte[] actualInBuf = new byte[len];
        System.arraycopy(inBuf, offset, actualInBuf, 0, len);
        
        gss_buffer_desc inputMsg = new gss_buffer_desc();
        if (inBuf != null && len > 0) {
            gsswrapper.setDescArray(inputMsg, actualInBuf);
            inputMsg.setLength(actualInBuf.length);
        }

        /* determine requested level of confidentiality and integrity */
        if (msgProp.getPrivacy())
            conf_req = 1;

        maj_status = gsswrapper.gss_wrap(min_status, this.internGSSCtx,
                conf_req, msgProp.getQOP(), inputMsg, state, outputMsg);

        if (maj_status != gsswrapper.GSS_S_COMPLETE) {
            throw new GSSExceptionImpl((int) maj_status, (int) min_status[0]);
        }

        /* Set the actual privacy state applied for caller to use */
        if (state[0] == 0)
            msgProp.setPrivacy(false);
        else
            msgProp.setPrivacy(true);
        
        /* get the byte[] from our outputMsg and return */
        if (outputMsg.getLength() > 0) {
            byte[] temp_msg = new byte[(int)outputMsg.getLength()];
            temp_msg = gsswrapper.getDescArray(outputMsg);
            gsswrapper.gss_release_buffer(min_status, outputMsg);
            return temp_msg;
        } else {
            return null;
        }
    }

    public void wrap(InputStream inStream, OutputStream outStream, 
            MessageProp msgProp) throws GSSException {
        // TODO
    }

    public byte[] unwrap(byte[] inBuf, int offset, int len,
            MessageProp msgProp) throws GSSException {
        // TODO
        return null;
    }

    public void unwrap(InputStream inStream, OutputStream outStream,
            MessageProp msgProp) throws GSSException {
        // TODO
    }

    public byte[] getMIC(byte[] inMsg, int offset, int len,
            MessageProp msgProp) throws GSSException {
        // TODO
        return null;
    }

    public void getMIC(InputStream inStream, OutputStream outStream,
            MessageProp msgProp) throws GSSException {
        // TODO
    }

    public void verifyMIC(byte[] inTok, int tokOffset, int tokLen,
            byte[] inMsg, int msgOffset, int msgLen,
            MessageProp msgProp) throws GSSException {
        // TODO
    }

    public void verifyMIC(InputStream tokStream, InputStream msgStream,
            MessageProp msgProp) throws GSSException {
        // TODO
    }

    public byte[] export() throws GSSException {
        // TODO
        return null;
    }

    public void requestMutualAuth(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestMutualAuth = true;
    }

    public void requestReplayDet(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestReplayDet = true;
    }

    public void requestSequenceDet(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestSequenceDet = true;
    }

    public void requestCredDeleg(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestCredDeleg = true;
    }

    public void requestAnonymity(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestAnonymity = true;
    }

    public void requestConf(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestConf = true;
    }

    public void requestInteg(boolean state) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            requestInteg = true;
    }

    public void requestLifetime(int lifetime) throws GSSException {
        if (ctxState == State.UNINIT && initiator)
            this.lifetime = lifetime;
    }

    // TODO: is this right?
    public void setChannelBinding(ChannelBinding cb) throws GSSException {
        if (ctxState == State.UNINIT)
            channelBinding = cb;
    }

    public boolean getCredDelegState() {
        return requestCredDeleg;
    }

    public boolean getMutualAuthState() {
        return requestMutualAuth;
    }

    public boolean getReplayDetState() {
        return requestReplayDet;
    }

    public boolean getSequenceDetState() {
        return requestSequenceDet;
    }

    public boolean getAnonymityState() {
        return requestAnonymity;
    }

    public boolean isTransferable() throws GSSException {
        if (ctxState == State.DONE)
            return isTransferable;
        return false;
    }

    public boolean isProtReady() {
        return isProtReady;
    }

    public boolean getConfState() {
        return requestConf;
    }

    public boolean getIntegState() {
        return requestInteg;
    }

    public int getLifetime() {
        return lifetime;
    }

    public GSSName getSrcName() {
        if (ctxState == State.DONE || isProtReady())
            return srcName;
        return null;
    }

    public GSSName getTargName() {
        if (ctxState == State.DONE || isProtReady())
            return targetName;
        return null;
    }

    public Oid getMech() throws GSSException {
        return mech;
    }

    public GSSCredential getDelegCred() throws GSSException {
        if (ctxState == State.DONE) {
            return delegCredential;
        }
        return null;
    }

    public boolean isInitiator() throws GSSException {
        if (ctxState == State.INPROG || ctxState == State.DONE)
            return initiator;
        return false;
    }

    private long getRequestedFlags() {
    
        long requestedFlags = 0;

        if (requestCredDeleg)
            requestedFlags ^= gsswrapper.GSS_C_DELEG_FLAG;
        if (requestMutualAuth)
            requestedFlags ^= gsswrapper.GSS_C_MUTUAL_FLAG;
        if (requestReplayDet)
            requestedFlags ^= gsswrapper.GSS_C_REPLAY_FLAG;
        if (requestSequenceDet)
            requestedFlags ^= gsswrapper.GSS_C_SEQUENCE_FLAG;
        if (requestConf)
            requestedFlags ^= gsswrapper.GSS_C_CONF_FLAG;
        if (requestInteg)
            requestedFlags ^= gsswrapper.GSS_C_INTEG_FLAG;
        if (requestAnonymity)
            requestedFlags ^= gsswrapper.GSS_C_ANON_FLAG;

        return requestedFlags;
    }

    private void setReturnedFlags(long retFlags) {

        /* since request*() methods are only valid before context
           creation, we'll just re-use those variables to indicate the
           current flags of the established context as well */

        // clear current flag values
        requestAnonymity = false;
        requestConf = false;
        requestCredDeleg = false;
        requestInteg = false;
        requestMutualAuth = false;
        requestReplayDet = false;
        requestSequenceDet = false;
        isProtReady = false;
        isTransferable = false;

        // set the new flags
        if ((retFlags & gsswrapper.GSS_C_ANON_FLAG) != 0)
            requestAnonymity = true;
        if ((retFlags & gsswrapper.GSS_C_CONF_FLAG) != 0)
            requestConf = true;
        if ((retFlags & gsswrapper.GSS_C_DELEG_FLAG) != 0)
            requestCredDeleg = true;
        if ((retFlags & gsswrapper.GSS_C_INTEG_FLAG) != 0)
            requestInteg = true;
        if ((retFlags & gsswrapper.GSS_C_MUTUAL_FLAG) != 0)
            requestMutualAuth = true;
        if ((retFlags & gsswrapper.GSS_C_REPLAY_FLAG) != 0)
            requestReplayDet = true;
        if ((retFlags & gsswrapper.GSS_C_SEQUENCE_FLAG) != 0)
            requestSequenceDet = true;
        if ((retFlags & gsswrapper.GSS_C_PROT_READY_FLAG) != 0)
            isProtReady = true;
        if ((retFlags & gsswrapper.GSS_C_TRANS_FLAG) != 0)
            isTransferable = true;
    }

}
